---
title: "inertia_coordination"
author: "Emily Butler, eabutler@u.arizona.edu"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{inertia_coordination}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
knitr::opts_knit$set(global.par=TRUE)
)
```

As for all _rties_ analyses, the first step for an Inertia-Coordination analysis is to follow the instructions in “overview_data_prep” to visualize and prepare the data. We include only the minimal required steps here:

```{r}
library(rties)
data1 <- rties_ExampleData_2
```
```{r, include=FALSE}
dyads <- c(19)
data1 <- removeDyads(data1, dyads, data1$couple)
```

The Inertia-Coordination model represents the within-person pattern of inertia, which is defined as the extent to which a person’s state can be predicted from his or her own state at a prior time point, and the between-person pattern of coordination, which is defined as the extent to which one partner’s state can be predicted from their partner’s state either concurrently or time-lagged (Reed, Randall, Post, & Butler, 2013). Specifically, the time-series state variable is predicted by the following: 1) separate intercepts for each partner, 2) a person’s own state variable at a prior time point, which gives two “inertia” estimates, one for each partner, and 3) the person’s partner’s state variable at the same prior time point, which gives two “coordination” estimates, again one for each partner. This model is identical to the "Stability-Influence" model (Thorson, West & Mendes, 2017), but we prefer the terms "inertia" and "coordination" because they have fewer connotations (that may or may not be appropriate for a given research design), than "stability" and "influence". The lm model used by the _rties_ functions is:    

lm(obs_deTrend ~ -1 + dist0 + dist1 + dist0:obs_deTrend_Lag + dist0:p_obs_deTrend_Lag + dist1:obs_deTrend_Lag + dist1:p_obs_deTrend_Lag, na.action=na.exclude, data=datai)

where “obs_deTrend” is the observed state variable with individual linear trends removed (e.g., it is the residuals from each person’s state variable predicted from time). The “-1” , “dist0” and “dist1” work together to implement a two-intercept model, whereby the overall intercept is omitted and instead separate intercepts are estimated for the level-0 and level-1 of the distinguisher variable provided by the user (for a discussion of this approach see: Kenny, Kashy, & Cook, 2006). The terms “dist0:obs_deTrend_Lag” and “dist1:obs_deTrend_Lag” estimate the inertia parameters for the partners scored 0 and 1 respectively on the distinguishing variable (e.g., “obs_deTrend_Lag” is the person’s own de-trended observed state variable lagged by how ever many steps the user specifies). Similarly, “dist0:p_obs_deTrend_Lag” and “dist1:p_obs_deTrend_Lag” estimate the coordination parameters for the partners scored 0 and 1 respectively on the distinguishing variable (e.g., “p_obs_deTrend_Lag” is the person’s partner's de-trended observed state variable lagged by how ever many steps the user specifies). The model is estimated separately for each dyad (e.g., “datai” is the data from couple “i”).     

Positive inertia estimates imply slower fluctuations of the state variable, while negative inertia estimates imply that the observed variable is oscillating back and forth between each lag (see Figures in overview_data_prep). For the between-person coordination parameters, a positive estimate implies an in-phase pattern, such that when one partner is high on the observed state variable, so is their partner at the specified lag, while a negative parameter implies an anti-phase pattern, such that when one partner is high the other partner is low at the specified lag (Randall, Post, Reed, & Butler, 2013; Reed et al., 2013; Wilson et al., 2018). 

### Sample Size Considerations

There are two sample size considerations for any of the models implemented in _rties_. The first pertains to the number of observations per dyad that are required, while the second is the number of dyads required. The first consideration comes into play when we estimate the dynamics one dyad at a time. Greater complexity requires finer-grained measurement of time and hence more observations per dyad. One advantage of the Inertia-Coordination model is that it is fairly simple and hence requires relatively few observations per dyad. The exact number will depend on how much variance there is over time, both within-people and between-partners, but it is likely to provide good results with as few as 5 observations per dyad (someone should do a simulation study of this!).     

The second sample size consideration comes into play when we use latent profiles based on the estimated dynamic parameters for each dyad to either predict the system variable, or be predicted by it. In both cases, the system variable can be either a dyadic variable (e.g., both partners have the same score, as in relationship length) or an individual variable (e.g., partners can have different scores, as in age). In the case of predicting a dyadic system variable, a regular regression model is appropriate for normally distributed system variables, or a generalized linear model for non-normal ones (any of the families available for glm can be used). In this case, the shared system variable is predicted by the categorical latent profile membership and you can use your favorite rule of thumb along the lines of “n observations for a one-predictor regression model” to choose your sample size. Alternately, you could conduct a power analysis for the linear (e.g., regular regression) or generalized linear model you choose. 

The situation is more complicated when the system variable is assessed at the individual level, or when it is the predictor of the latent profiles. In the former case, the system variable is predicted using a cross-sectional random-intercept dyadic model with the latent profile membership, the distinguisher variable and their interaction as fixed effects. For these models, it should be possible to use the R package _simr_ to estimate the necessary sample size to obtain desired power. In the latter case, profile membership is predicted using either a binomial (for 2 latent profiles) or multinomial (for more than 2 latent profiles) model, with either just the system variable as a predictor (for dyadic system variables), or each partner's system variable and their interaction as predictors (for individual system variables). For these models, it should be possible to use G-Power, or some other software for logistic and multinomial regression, to assess the needed sample size for a given power level.

### Choosing the Lag Length

One complexity in using the Inertia-Coordination model is that the results are highly dependent upon the chosen lag length (for discussion of a similar issue when choosing the measurement interval see: Boker & Nesselroade, 2002). This dependence on the lag makes interpretation problematic unless one has a strong theory about the temporal processes at work. At a minimum, it is a good idea to inspect the auto-correlation (relevant to inertia) and cross-correlation (relevant to coordination) plots for the observed state variables. If the state variables are oscillating at all, the auto- and cross- correlations will also oscillate depending on lag. For example, the correlations can vary from negative, to zero, to positive depending on the lag. To facilitate making an informed decision about lag length, _rties_ provides functions to produce auto- and cross- correlation plots. Here we plot a chosen subset of dyads to show the strong impact that is sometimes found due to lag, especially for cross-correlation. 

```{r, include=FALSE}
par(mar=c(1,1,1,1))
```
```{r}
temp <- subset(data1, couple %in% c(2,5,27,31,47,60,103,110))
autoCorPlots(temp, "person","couple","dial","time")
crossCorPlots(temp, "person","couple","dial","time")
```

Choosing the lag relies on a combination of theory, prior research, and how quickly you expect the phenomenon of interest to be changing (see Thorson, West & Mendes, 2017, for additional discussion). For example, if the process is fairly stable, auto-correlation will be high across a long lag time and will dominate any results. The stronger the autocorrelation is, the weaker the cross-correlation will be (this results from the behavior of multiple regression models, where the coordination parameters can only account for independent variance in the outcome after accounting for inertia). Thus part of the decision depends upon how much of the observed state variables behavior you want to be explained by within-person auto-correlation processes versus how much you prefer to prioritize between-person cross-correlations. Another consideration is how many observation time points there were. For each lag you lose one observation point (e.g., if the lag is two steps, then the parameter estimates will be based on the total number of observations per dyad minus 2). One strength of _rties_ is that it makes it very easy to alter the lag length and observe the impact on the results, which is helpful for developing an intuitive understanding of inertia and coordination.    

### Assessing Model Fit

Having chosen a lag length, based either on theory or inspection, we complete the data preparation process. Here we include the system variable of "convQual" and choose a lag length of 3 (see "overview_data_prep" for the basis of our chosen lag).

```{r}
data2 <- dataPrep(data1, "person","couple", "dial","convQual","female","time", time_lag=3)
```

The next step, which is often neglected in the literature, is to assess how well different variants of the Inertia-Coordination model fit the observed temporal data. Our ultimate goal is to either predict outcomes of interest from the dynamics assessed by the model, or to test whether other variables predict those dynamics. Either way, the results are only meaningful if the Inertia-Coordination model does, in fact, realistically represent the dynamics of the system. We therefore provide a function, indivInertCoordCompare, that fits three versions of the model (inertia-only, coordination-only, inertia and coordination) to each dyad's data and returns a named list that includes: 1) the adjusted R^2 for each dyad for each of the 3 models (“R2inert”, “R2coord” and “R2inertCoord” e.g., how well each model predicts the observed temporal trajectories of the data), and 2) differences between the R2 for each model, where "R2dif_I_C" is the R2 for the inertia-only model minus the coordination-only model, "R2dif_IC_I" (inertia-coordination minus inertia), and "R2dif_IC_C" (inertia-coordination minius coordination-only). The function takes the name of the processed dataframe, here "data2", and the results can be accessed with the summary function: 

```{r}
compare <- indivInertCoordCompare(data2)
summary(compare$R2inert)
summary(compare$R2coord)
summary(compare$R2inertCoord)
summary(compare$R2dif_IC_I)
```
In this example, we see that the full model accounts for 35% on average of the variance in the observed state variables, while the inertia-only model accounts for almost as much (34%) and the coordination-only model accounts for only 9% on average and adds only about 1% to the inertia-only model when included in the full model. These results suggest that coordination is not important for describing the dynamics of the system, over and above inertia. It is still possible, however, that the small amount of variance explained by coordination may predict system variables, such as relationship quality or health, better than the larger amount of variance explained by inertia.    

In addition to the model comparison results, we provide a function, indivInertCoordPlots, to plot the observed state variables for each dyad, superimposed with their model predicted trajectories. The function takes as arguments the name of the processed dataframe, which of the 3 variants of the inertia-coordination model to plot the results for ("inert"", "coord"", "inertCoord""), and optional strings providing labels for the level-0 and level-1 of the distinguishing variable. These plots provide a visual tool for assessing model fit at the individual dyad level. The figures can be accessed from the returned list called “plots” and they are also automatically saved as a .pdf file in the working directory (this process takes awhile). The following figures show examples of poor and good fit respectively:
```{r, eval=FALSE}
figures <- indivInertCoordPlots(data2, "inertCoord", dist0name="Men", dist1name="Women")
```
![Alt text](IC_poorFit.png) ![](IC_goodFit.png) 

### Generating Dynamic Parameter Estimates

The next step is to use the function “indivInertCoord” to generate the dynamic parameter estimates for each dyad. The function takes the name of the processed dataframe ("data2" in this example) and the name of the version of the inertia-coordination model that you want the parameter estimates for ("inert", "coord", or "inertCoord"). It returns: 1) a dataframe containing both the parameter estimates for the model for each dyad and the system variable (called "data", for using the dynamic parameters to either predict, or be predicted by, the system variable), 2) a dataframe with just the parameter estimates (called "params", for use in the latent profile analysis), and 3) a vector with the adjusted R^2 for the model fit to each dyad's data (called R^2; this R^2 information is identical to that returned by indivInertCoordCompare).
```{r}
ic <- indivInertCoord(data2, "inertCoord")
names(ic)
head(ic$data)
```
In the returned data, "int0" and "int1" are the estimated intercepts for the partner scored 0 amd 1 on the distinguisher respectively (e.g., their estimated state variable at time zero). The variables "inert0" and "inert1" are the inertia estimates for each partner and "coord0" and "coord1" are their coordination estimates respectively. The other variables are the dyad and individual IDs, the partner's scores on the system variable (self-reported conversation quality in this example), and dist0 is scored 1 for the partner scored 0 on the original distinguishing variable (in this example the men) and scored 0 for the partner scored 1 on the original variable (in this case the women). 

### Latent Profile Analysis

The next step is to use the data generated by “indivInertCoord” as input to a latent profile analysis. Because the models in _rties_ all represent non-linear dynamics, the behavior of the dyadic system cannot be intuited by examining individual parameter estimates from the model. Rather, they operate together as a set to produce potentially complex temporal trajectories of both partner's state variables (emotional experience in this example). Thus when it comes to using the dynamic parameter estimates to predict, or be predicted by, system variables such as conversation quality, we wish the parameters to be operating as a set, not as isolated individual predictors or outcomes (such as would be the case if we used them as predictors in a regression model). Instead, we use them as input to a latent profile analysis in order to estimate qualitatively distinct groups of dyads based on the dynamics assessed by the model (in this case, by the inertia-coordination model). In other words, we wish to group the dyads based on their similarities and differences in terms of patterns of inertia and coordination. 

The latent profile analysis makes use of the _tidyLPA_ package and we recommend consulting their documentation for a full understanding. We focus here on its specific use in the context of _rties_. We first load the _tidyLPA_ package (you will need to install it if you haven't already) and use the dynamic parameter estimates in "ic$params" as input to the _tidyLPA_ "compare_solutions" function. It takes the name of the dataframe we just created with the parameter estimates and the names of which parameter estimates to include in the analysis. Here we include both partner's inertia and coordination, but not their intercepts. The result is a plot showing the BIC fit statistic for various models with various numbers of profiles (see _tidyLPA_ documentation for a full interpretation).
```{r, fig.width=8}
library(tidyLPA)
compare_solutions(ic$params, inert1, coord1, coord0, inert0)
```

The previous output can be used to make decisions about which model and how many profiles to use. We recommend reading some papers on latent profile analysis if this is new to you. Here we choose model 6 with 2 profiles. The next step is to investigate the make up of the estimated profiles using the "estimate_profiles" function.
```{r, fig.width=4}
lpaStep1 <- estimate_profiles(ic$params, inert1, coord1, coord0, inert0, n_profiles=2, variances="varying", covariances="varying")
plot_profiles(lpaStep1)
```

We see from the resulting plot that the profiles are primarily distinguished by "Profile 1" having coordination parameters around zero, while "Profile 2" has positive coordination parameters. There is also a difference in the inertia parameters for the partner scored 1 on the original distinguishing variable (women in our example), with higher inertia for that partner in "Profile 2" than "Profile 1". 

You could repeat the previous steps with different models and numbers of profiles. Once you have chosen the final combination to use moving forward, the next step is to run the "estimate_profiles" two more times with different return options in order to collect the information needed for using the latent profiles as either predictors or outcomes of the system variable. Specifically, the object "lpaStep2" below is created using the "return_orig_df=T" argument, while the object "lpaStep3" uses the "to_return="mclust"" argument. Those objects are then used as input to the _rties_ function "makeLpaData", along with the dataframe created by the "indivInertCoord" function and the name of the model that generated the estimates (either "inertCoord" or "clo"). The result (called "lpaVars" in this example) contains the needed data (called "profileData") and parameter estimates (called "profileParams") for all subsequent steps in the analysis.
```{r}
lpaStep2 <- estimate_profiles(ic$params, inert1, coord1, coord0, inert0, n_profiles= 2, variances="varying", covariances="varying", return_orig_df=T)

lpaStep3 <- estimate_profiles(ic$params, inert1, coord1, coord0, inert0, n_profiles= 2, variances="varying", covariances="varying", to_return="mclust")

lpaVars <- makeLpaData(ic$data, lpaStep2, lpaStep3, "inertCoord")
```
### Plotting the Dynamic Trajectories for Each Profile

